GAS LISTING /tmp/cccvrElj.s 			page 1


   1               		.file	"rev2.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.stabs	"/home/ffg/DATA/Electronics/AVR/PSU/",100,0,2,.Ltext0
   8               		.stabs	"rev2.c",100,0,2,.Ltext0
   9               		.text
  10               	.Ltext0:
  11               		.stabs	"gcc2_compiled.",60,0,0,0
  12               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,0,0
  13               		.stabs	"char:t(0,2)=@s8;r(0,2);0;255;",128,0,0,0
  14               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,0,0
  15               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,0,0
  16               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,0,0
  17               		.stabs	"long long int:t(0,6)=@s64;r(0,6);01000000000000000000000;0777777777777777777777;",128,0,0,
  18               		.stabs	"long long unsigned int:t(0,7)=@s64;r(0,7);0;01777777777777777777777;",128,0,0,0
  19               		.stabs	"short int:t(0,8)=r(0,8);-32768;32767;",128,0,0,0
  20               		.stabs	"short unsigned int:t(0,9)=r(0,9);0;0177777;",128,0,0,0
  21               		.stabs	"signed char:t(0,10)=@s8;r(0,10);-128;127;",128,0,0,0
  22               		.stabs	"unsigned char:t(0,11)=@s8;r(0,11);0;255;",128,0,0,0
  23               		.stabs	"float:t(0,12)=r(0,1);4;0;",128,0,0,0
  24               		.stabs	"double:t(0,13)=r(0,1);4;0;",128,0,0,0
  25               		.stabs	"long double:t(0,14)=r(0,1);4;0;",128,0,0,0
  26               		.stabs	"void:t(0,15)=(0,15)",128,0,0,0
  27               		.stabs	"rev2.h",130,0,0,0
  28               		.stabs	"/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/io.h",130,0,0,0
  29               		.stabs	"/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/sfr_defs.h",130,0,0,0
  30               		.stabs	"/usr/lib/gcc/avr/4.7.2/../../../avr/include/inttypes.h",130,0,0,0
  31               		.stabs	"/usr/lib/gcc/avr/4.7.2/include/stdint.h",130,0,0,0
  32               		.stabs	"/usr/lib/gcc/avr/4.7.2/../../../avr/include/stdint.h",130,0,0,0
  33               		.stabs	"int8_t:t(6,1)=(0,10)",128,0,121,0
  34               		.stabs	"uint8_t:t(6,2)=(0,11)",128,0,122,0
  35               		.stabs	"int16_t:t(6,3)=(0,1)",128,0,123,0
  36               		.stabs	"uint16_t:t(6,4)=(0,4)",128,0,124,0
  37               		.stabs	"int32_t:t(6,5)=(0,3)",128,0,125,0
  38               		.stabs	"uint32_t:t(6,6)=(0,5)",128,0,126,0
  39               		.stabs	"int64_t:t(6,7)=(0,6)",128,0,128,0
  40               		.stabs	"uint64_t:t(6,8)=(0,7)",128,0,129,0
  41               		.stabs	"intptr_t:t(6,9)=(6,3)",128,0,142,0
  42               		.stabs	"uintptr_t:t(6,10)=(6,4)",128,0,147,0
  43               		.stabs	"int_least8_t:t(6,11)=(6,1)",128,0,159,0
  44               		.stabs	"uint_least8_t:t(6,12)=(6,2)",128,0,164,0
  45               		.stabs	"int_least16_t:t(6,13)=(6,3)",128,0,169,0
  46               		.stabs	"uint_least16_t:t(6,14)=(6,4)",128,0,174,0
  47               		.stabs	"int_least32_t:t(6,15)=(6,5)",128,0,179,0
  48               		.stabs	"uint_least32_t:t(6,16)=(6,6)",128,0,184,0
  49               		.stabs	"int_least64_t:t(6,17)=(6,7)",128,0,192,0
  50               		.stabs	"uint_least64_t:t(6,18)=(6,8)",128,0,199,0
  51               		.stabs	"int_fast8_t:t(6,19)=(6,1)",128,0,213,0
  52               		.stabs	"uint_fast8_t:t(6,20)=(6,2)",128,0,218,0
  53               		.stabs	"int_fast16_t:t(6,21)=(6,3)",128,0,223,0
  54               		.stabs	"uint_fast16_t:t(6,22)=(6,4)",128,0,228,0
  55               		.stabs	"int_fast32_t:t(6,23)=(6,5)",128,0,233,0
  56               		.stabs	"uint_fast32_t:t(6,24)=(6,6)",128,0,238,0
  57               		.stabs	"int_fast64_t:t(6,25)=(6,7)",128,0,246,0
GAS LISTING /tmp/cccvrElj.s 			page 2


  58               		.stabs	"uint_fast64_t:t(6,26)=(6,8)",128,0,253,0
  59               		.stabs	"intmax_t:t(6,27)=(6,7)",128,0,273,0
  60               		.stabs	"uintmax_t:t(6,28)=(6,8)",128,0,278,0
  61               		.stabn	162,0,0,0
  62               		.stabn	162,0,0,0
  63               		.stabs	"int_farptr_t:t(4,1)=(6,5)",128,0,77,0
  64               		.stabs	"uint_farptr_t:t(4,2)=(6,6)",128,0,81,0
  65               		.stabn	162,0,0,0
  66               		.stabn	162,0,0,0
  67               		.stabs	"/usr/lib/gcc/avr/4.7.2/../../../avr/include/avr/fuse.h",130,0,0,0
  68               		.stabs	"__fuse_t:t(7,1)=(7,2)=s2low:(0,11),0,8;high:(0,11),8,8;;",128,0,252,0
  69               		.stabn	162,0,0,0
  70               		.stabn	162,0,0,0
  71               		.stabs	"LCD.h",130,0,0,0
  72               		.stabs	"/usr/lib/gcc/avr/4.7.2/../../../avr/include/stdio.h",130,0,0,0
  73               		.stabs	"/usr/lib/gcc/avr/4.7.2/include/stdarg.h",130,0,0,0
  74               		.stabs	"__gnuc_va_list:t(10,1)=(10,2)=*(0,15)",128,0,40,0
  75               		.stabs	"va_list:t(10,3)=(10,1)",128,0,102,0
  76               		.stabn	162,0,0,0
  77               		.stabs	"/usr/lib/gcc/avr/4.7.2/include/stddef.h",130,0,0,0
  78               		.stabs	"size_t:t(11,1)=(0,4)",128,0,213,0
  79               		.stabn	162,0,0,0
  80               		.stabs	"__file:T(9,1)=s14buf:(9,2)=*(0,2),0,16;unget:(0,11),16,8;flags:(6,2),24,8;size:(0,1),32,16
  81               		.stabn	162,0,0,0
  82               		.stabn	162,0,0,0
  83               		.stabn	162,0,0,0
  84               		.stabs	"transferToDAC:F(0,15)",36,0,268,transferToDAC
  85               		.stabs	"CTRL:P(0,11)",64,0,268,24
  86               		.stabs	"a:P(6,4)",64,0,268,22
  87               	.global	transferToDAC
  88               		.type	transferToDAC, @function
  89               	transferToDAC:
  90               		.stabd	46,0,0
   1:rev2.c        **** /************************************
   2:rev2.c        **** *									*
   3:rev2.c        **** *		DIGITAL PSU REV 2			*			
   4:rev2.c        **** *		Fridrik F Gautason			*
   5:rev2.c        **** *		Copyright 2013				*
   6:rev2.c        **** *									*
   7:rev2.c        **** ************************************/
   8:rev2.c        **** 
   9:rev2.c        **** #include "rev2.h"
  10:rev2.c        **** 
  11:rev2.c        **** uint8_t backlight = 10;
  12:rev2.c        **** 
  13:rev2.c        **** int main(void)
  14:rev2.c        **** {
  15:rev2.c        **** 	DDRB = 0;
  16:rev2.c        **** 	DDRC = 0;
  17:rev2.c        **** 	DDRD = 0;
  18:rev2.c        **** 
  19:rev2.c        **** 	// Initialize the Switches and encoder
  20:rev2.c        **** 	SW_Initialize();
  21:rev2.c        **** 	
  22:rev2.c        **** 	// DAC
  23:rev2.c        **** 	DDRD |= 1 << PD7;	// DAC chip select
  24:rev2.c        **** 	DESELECT_DAC;
GAS LISTING /tmp/cccvrElj.s 			page 3


  25:rev2.c        **** 
  26:rev2.c        **** 	// Output relay
  27:rev2.c        **** 	DDRB |= 1 << PB0;	// Output enable
  28:rev2.c        **** 	DISABLE_OUTPUT;
  29:rev2.c        **** 
  30:rev2.c        **** 	// SPI interface to DAC and DISPLAY
  31:rev2.c        **** 	DDRB |= 1 << PB3;	// SPI MOSI
  32:rev2.c        **** 	DDRB |= 1 << PB5;	// SPI SCK
  33:rev2.c        **** 	// Enable SPI, Master, set clock rate fck/16
  34:rev2.c        **** 	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
  35:rev2.c        **** 
  36:rev2.c        **** 	// Setting up OC1 which is the PWM module for
  37:rev2.c        **** 	// charge pump and backlight. The charge pump is 
  38:rev2.c        **** 	// always set on half duty cycle while backlight is 
  39:rev2.c        **** 	// controlled by the user.
  40:rev2.c        **** 	DDRB |= 1 << PB1;							// Charge pump
  41:rev2.c        **** 	DDRB |= 1 << PB2;							// Backlight
  42:rev2.c        **** 	TCCR1A  = (1 << COM1A1) | (1 << COM1B1);	// Enable both osc
  43:rev2.c        **** 	TCCR1A |= (1 << WGM10) | (1 << WGM12);		// FAST 8 bit PWM
  44:rev2.c        **** 	OCR1A = 0x80;								// charge pump 128
  45:rev2.c        **** 	OCR1B = backlight*19;						// Backlight
  46:rev2.c        **** 	TCCR1B = (1 << CS10);						// START no prescaler
  47:rev2.c        **** 	
  48:rev2.c        **** 	// A wanky opening screen
  49:rev2.c        **** 	LCD_Initialize();
  50:rev2.c        **** 	LCD_Cursor(0,4);
  51:rev2.c        **** 	LCD_Write("digital");
  52:rev2.c        **** 	LCD_Cursor(1,6);
  53:rev2.c        **** 	LCD_Write("PSU");
  54:rev2.c        **** 	_delay_ms(1000);
  55:rev2.c        **** 	LCD_Clear();
  56:rev2.c        **** 
  57:rev2.c        **** 	// Voltage and current read variables
  58:rev2.c        **** 	uint16_t voltageRead = 0;
  59:rev2.c        **** 	uint16_t coltagePreRead = 0;
  60:rev2.c        **** 	uint16_t currentRead = 0;
  61:rev2.c        **** 	uint16_t currentPreRead = 0;
  62:rev2.c        **** 	uint16_t preregRead = 0;
  63:rev2.c        **** 	uint16_t vinRead = 0;
  64:rev2.c        **** 	int numReadAverages = 50;
  65:rev2.c        **** 	int readCounter = 0;
  66:rev2.c        **** 
  67:rev2.c        **** 	// Voltage and current set variables
  68:rev2.c        **** 	uint16_t voltageSet = 0;
  69:rev2.c        **** 	uint16_t currentSet = 0;
  70:rev2.c        **** 
  71:rev2.c        **** 	// Delay variables, because we want to show the
  72:rev2.c        **** 	// set varibles for some while before we show the 
  73:rev2.c        **** 	// readback.
  74:rev2.c        **** 	uint16_t voltageSetDelay = 0;
  75:rev2.c        **** 	uint16_t currentSetDelay = 0;
  76:rev2.c        **** 	uint16_t numDelayCycles = 3000;
  77:rev2.c        **** 
  78:rev2.c        **** 	// Calibration variables
  79:rev2.c        **** 	float voltageRef = 498.8;	// The ref voltage times 100
  80:rev2.c        **** 	float voltageSetMulti = 4.7*voltageRef/1024;	// gain*ref/numBits
  81:rev2.c        **** 	float voltageReadMulti = 5.7*voltageRef/1024;
GAS LISTING /tmp/cccvrElj.s 			page 4


  82:rev2.c        **** 	float currentSetMulti = 1/0.33/11*voltageRef/1024;
  83:rev2.c        **** 	float currentReadMulti = 1/0.33/11*voltageRef/1024;
  84:rev2.c        **** 
  85:rev2.c        **** 	// Start the ADC
  86:rev2.c        **** 	ADC_initialize();
  87:rev2.c        **** 	ADC_STARTCONVERSION;
  88:rev2.c        **** 	sei();
  89:rev2.c        **** 
  90:rev2.c        **** 	// Start the USB interface
  91:rev2.c        **** 	USART_Initialize();
  92:rev2.c        **** 
  93:rev2.c        **** 	MENU_Home();
  94:rev2.c        **** 	LCD_Cursor(0,3);
  95:rev2.c        **** 	LCD_WriteFloat(voltageSet);
  96:rev2.c        **** 	LCD_Cursor(1,3);
  97:rev2.c        **** 	LCD_WriteFloat(currentSet);
  98:rev2.c        **** 
  99:rev2.c        **** 	/************************
 100:rev2.c        **** 	*						*
 101:rev2.c        **** 	*		MAIN LOOP		*
 102:rev2.c        **** 	*						*
 103:rev2.c        **** 	************************/
 104:rev2.c        **** 
 105:rev2.c        **** 	while(1)
 106:rev2.c        ****     {
 107:rev2.c        **** 		// If Sw1 is pressed, toggle the output
 108:rev2.c        **** 		if (SW_Check1())
 109:rev2.c        **** 		{
 110:rev2.c        **** 			if(OUTPUT_IS_ENABLED)
 111:rev2.c        **** 			{
 112:rev2.c        **** 				DISABLE_OUTPUT;
 113:rev2.c        **** 				LCD_Cursor(0,14);
 114:rev2.c        **** 				LCD_Write("  ");
 115:rev2.c        **** 			}
 116:rev2.c        **** 			else
 117:rev2.c        **** 			{
 118:rev2.c        **** 				ENABLE_OUTPUT;
 119:rev2.c        **** 				LCD_Cursor(0,14);
 120:rev2.c        **** 				LCD_Write("ON");
 121:rev2.c        **** 			}
 122:rev2.c        **** 		}
 123:rev2.c        **** 
 124:rev2.c        **** 		// If Sw2 is pressed, let the encoder control the backlight
 125:rev2.c        **** 		if (SW_Check2())
 126:rev2.c        **** 		{
 127:rev2.c        **** 			// Go into backlight setting
 128:rev2.c        **** 			MENU_Backlight();
 129:rev2.c        **** 			MENU_Home();
 130:rev2.c        **** 			LCD_Cursor(0,3);
 131:rev2.c        **** 			LCD_WriteFloat(voltageSet);
 132:rev2.c        **** 			LCD_Cursor(1,3);
 133:rev2.c        **** 			LCD_WriteFloat(currentSet);
 134:rev2.c        **** 		}
 135:rev2.c        **** 
 136:rev2.c        **** 		// IF Sw4 is pressed, toggle the encoder
 137:rev2.c        **** 		if (SW_Check4())
 138:rev2.c        **** 		{
GAS LISTING /tmp/cccvrElj.s 			page 5


 139:rev2.c        **** 			switch(encoderControls)
 140:rev2.c        **** 			{
 141:rev2.c        **** 			case VOLTAGE:
 142:rev2.c        **** 				encoderControls = CURRENT;
 143:rev2.c        **** 				LCD_Cursor(0,2);
 144:rev2.c        **** 				LCD_Write(" ");
 145:rev2.c        **** 				LCD_Cursor(1,2);
 146:rev2.c        **** 				LCD_Write("~");
 147:rev2.c        **** 				break;
 148:rev2.c        **** 			case CURRENT:
 149:rev2.c        **** 				encoderControls = VOLTAGE;
 150:rev2.c        **** 				LCD_Cursor(0,2);
 151:rev2.c        **** 				LCD_Write("~");
 152:rev2.c        **** 				LCD_Cursor(1,2);
 153:rev2.c        **** 				LCD_Write(" ");
 154:rev2.c        **** 				break;
 155:rev2.c        **** 			default:
 156:rev2.c        **** 				encoderControls = VOLTAGE;
 157:rev2.c        **** 				LCD_Cursor(0,2);
 158:rev2.c        **** 				LCD_Write("~");
 159:rev2.c        **** 				LCD_Cursor(1,2);
 160:rev2.c        **** 				LCD_Write(" ");
 161:rev2.c        **** 				break;
 162:rev2.c        **** 			}
 163:rev2.c        **** 		}
 164:rev2.c        **** 
 165:rev2.c        **** 		
 166:rev2.c        **** 		// Rotary encoder
 167:rev2.c        **** 		unsigned char dir = SW_CheckEncoder();
 168:rev2.c        **** 		if(dir)
 169:rev2.c        **** 		{
 170:rev2.c        **** 			switch(encoderControls)
 171:rev2.c        **** 			{		
 172:rev2.c        **** 			case VOLTAGE:
 173:rev2.c        **** 				if(dir == ENCODER_CW)	voltageSet += 2;
 174:rev2.c        **** 				else 					voltageSet -= 2;
 175:rev2.c        **** 
 176:rev2.c        **** 				if(voltageSet > 60000)
 177:rev2.c        **** 					voltageSet = 0;
 178:rev2.c        **** 				else if(voltageSet > 2000)
 179:rev2.c        **** 					voltageSet = 2000;
 180:rev2.c        **** 
 181:rev2.c        **** 				transferToDAC(9,voltageSet/voltageSetMulti);
 182:rev2.c        **** 				LCD_Cursor(0,3);
 183:rev2.c        **** 				LCD_WriteFloat(voltageSet);
 184:rev2.c        **** 				// Set delay to keep displaying the set voltage
 185:rev2.c        **** 				// for some time
 186:rev2.c        **** 				voltageSetDelay = numDelayCycles;
 187:rev2.c        **** 				break;
 188:rev2.c        **** 			case CURRENT:
 189:rev2.c        **** 				if(dir == ENCODER_CW) 	currentSet += 1;
 190:rev2.c        **** 				else					currentSet -= 1;
 191:rev2.c        **** 
 192:rev2.c        **** 				if(currentSet > 60000)
 193:rev2.c        **** 					currentSet = 0;
 194:rev2.c        **** 				else if(currentSet > 100)
 195:rev2.c        **** 					currentSet = 100;
GAS LISTING /tmp/cccvrElj.s 			page 6


 196:rev2.c        **** 
 197:rev2.c        **** 				transferToDAC(10,currentSet/currentSetMulti);
 198:rev2.c        **** 				LCD_Cursor(1,3);
 199:rev2.c        **** 				LCD_WriteFloat(currentSet);
 200:rev2.c        **** 				currentSetDelay = numDelayCycles;
 201:rev2.c        **** 				break;
 202:rev2.c        **** 			default:
 203:rev2.c        **** 				break;
 204:rev2.c        **** 			}
 205:rev2.c        **** 		}
 206:rev2.c        **** 	
 207:rev2.c        **** 		// Reduce set delays by one
 208:rev2.c        **** 		if (voltageSetDelay > 0)
 209:rev2.c        **** 			voltageSetDelay--;
 210:rev2.c        **** 		if (currentSetDelay > 0)
 211:rev2.c        **** 			currentSetDelay--;
 212:rev2.c        **** 
 213:rev2.c        **** 		// When a new ADC reading is registered we display it
 214:rev2.c        **** 		if(ADC_status & ADC_NEWREADING)
 215:rev2.c        **** 		{
 216:rev2.c        **** 			ADC_status &= ~ADC_NEWREADING;
 217:rev2.c        **** 
 218:rev2.c        **** 			switch(ADC_status)
 219:rev2.c        **** 			{
 220:rev2.c        **** 			case ADC_VOLTAGE:
 221:rev2.c        **** 				voltageRead = ADC_reading*voltageReadMulti;
 222:rev2.c        **** 				ADC_status = ADC_CURRENT;
 223:rev2.c        **** 				ADMUX &= 0xF0;
 224:rev2.c        **** 				ADMUX |= CURRENT_MON;
 225:rev2.c        **** 				if (voltageSetDelay == 0)
 226:rev2.c        **** 				{
 227:rev2.c        **** 					LCD_Cursor(0,3);
 228:rev2.c        **** 					LCD_WriteFloat(voltageRead);
 229:rev2.c        **** 					USART_Transmit(voltageRead);
 230:rev2.c        **** 				}
 231:rev2.c        **** 				break;
 232:rev2.c        **** 			case ADC_CURRENT:
 233:rev2.c        **** 				currentRead = ADC_reading*currentReadMulti;
 234:rev2.c        **** 				ADC_status = ADC_PREREGULATOR;
 235:rev2.c        **** 				ADMUX &= 0xF0;
 236:rev2.c        **** 				ADMUX |= PREREG;
 237:rev2.c        **** 				if (currentSetDelay == 0)
 238:rev2.c        **** 				{
 239:rev2.c        **** 					LCD_Cursor(1,3);
 240:rev2.c        **** 					LCD_WriteFloat(currentRead);
 241:rev2.c        **** 				}
 242:rev2.c        **** 				break;
 243:rev2.c        **** 			case ADC_PREREGULATOR:
 244:rev2.c        **** 				preregRead = ADC_reading*voltageReadMulti;
 245:rev2.c        **** 				ADC_status = ADC_VIN;
 246:rev2.c        **** 				ADMUX &= 0xF0;
 247:rev2.c        **** 				ADMUX |= VIN_MON;
 248:rev2.c        **** 				break;
 249:rev2.c        **** 			case ADC_VIN:
 250:rev2.c        **** 				vinRead = ADC_reading*voltageReadMulti;
 251:rev2.c        **** 				ADC_status = ADC_VOLTAGE;
 252:rev2.c        **** 				ADMUX &= 0xF0;
GAS LISTING /tmp/cccvrElj.s 			page 7


 253:rev2.c        **** 				ADMUX |= VOLTAGE_MON;
 254:rev2.c        **** 			default:
 255:rev2.c        **** 				ADC_status = ADC_VOLTAGE;
 256:rev2.c        **** 				ADMUX &= 0xF0;
 257:rev2.c        **** 				ADMUX |= VOLTAGE_MON;
 258:rev2.c        **** 				break;
 259:rev2.c        **** 			}
 260:rev2.c        **** 			ADC_STARTCONVERSION;
 261:rev2.c        **** 		}
 262:rev2.c        **** 	}
 263:rev2.c        **** }
 264:rev2.c        **** 
 265:rev2.c        **** // For the DAC (LTC1661) we must give one 16bit word 
 266:rev2.c        **** // first four bits are control code, the next eight 
 267:rev2.c        **** // are the actual data and the last two are ignored.
 268:rev2.c        **** void transferToDAC(unsigned char CTRL,uint16_t a){
  91               		.stabn	68,0,268,.LM0-.LFBB1
  92               	.LM0:
  93               	.LFBB1:
  94               	/* prologue: function */
  95               	/* frame size = 0 */
  96               	/* stack size = 0 */
  97               	.L__stack_usage = 0
 269:rev2.c        ****   	// Make sure a is a ten bit word
 270:rev2.c        ****   	a &= 0x03FF;
  98               		.stabn	68,0,270,.LM1-.LFBB1
  99               	.LM1:
 100 0000 7370      		andi r23,3
 271:rev2.c        **** 	// Then shift up by two bits, the DAC does not
 272:rev2.c        **** 	// care about the two last bits!
 273:rev2.c        **** 	//a = a << 2; 
 274:rev2.c        **** 	// Shift the control code up by 4 bits
 275:rev2.c        **** 	CTRL = CTRL << 4;
 276:rev2.c        **** 
 277:rev2.c        **** 	// Now we can transfer this to the DAC
 278:rev2.c        ****   	// Take the DAC chip select low
 279:rev2.c        ****   	SELECT_DAC;
 101               		.stabn	68,0,279,.LM2-.LFBB1
 102               	.LM2:
 103 0002 9798      		cbi 0x12,7
 280:rev2.c        ****   	// Transfer in two 8 bit steps
 281:rev2.c        ****   	SPDR = CTRL | (a >> 6);
 104               		.stabn	68,0,281,.LM3-.LFBB1
 105               	.LM3:
 106 0004 9B01      		movw r18,r22
 107 0006 96E0      		ldi r25,6
 108               		1:
 109 0008 3695      		lsr r19
 110 000a 2795      		ror r18
 111 000c 9A95      		dec r25
 112 000e 01F4      		brne 1b
 275:rev2.c        **** 	CTRL = CTRL << 4;
 113               		.stabn	68,0,275,.LM4-.LFBB1
 114               	.LM4:
 115 0010 8295      		swap r24
 116 0012 807F      		andi r24,lo8(-16)
 117               		.stabn	68,0,281,.LM5-.LFBB1
GAS LISTING /tmp/cccvrElj.s 			page 8


 118               	.LM5:
 119 0014 822B      		or r24,r18
 120 0016 8FB9      		out 0xf,r24
 121               	.L2:
 282:rev2.c        **** 	while(!(SPSR & (1<<SPIF)));
 122               		.stabn	68,0,282,.LM6-.LFBB1
 123               	.LM6:
 124 0018 779B      		sbis 0xe,7
 125 001a 00C0      		rjmp .L2
 283:rev2.c        **** 	SPDR = (a << 2) & 0x00FF;
 126               		.stabn	68,0,283,.LM7-.LFBB1
 127               	.LM7:
 128 001c 660F      		lsl r22
 129 001e 660F      		lsl r22
 130 0020 6FB9      		out 0xf,r22
 131               	.L3:
 284:rev2.c        **** 	while(!(SPSR & (1<<SPIF)));
 132               		.stabn	68,0,284,.LM8-.LFBB1
 133               	.LM8:
 134 0022 779B      		sbis 0xe,7
 135 0024 00C0      		rjmp .L3
 285:rev2.c        ****   	// Restore the chip select
 286:rev2.c        ****   	DESELECT_DAC;
 136               		.stabn	68,0,286,.LM9-.LFBB1
 137               	.LM9:
 138 0026 979A      		sbi 0x12,7
 139 0028 0895      		ret
 140               		.size	transferToDAC, .-transferToDAC
 141               	.Lscope1:
 142               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 143               		.stabd	78,0,0
 144               		.section	.rodata.str1.1,"aMS",@progbits,1
 145               	.LC0:
 146 0000 563A 2000 		.string	"V: "
 147               	.LC1:
 148 0004 493A 2000 		.string	"I: "
 149               	.LC2:
 150 0008 7E00      		.string	"~"
 151               	.LC3:
 152 000a 4F4E 00   		.string	"ON"
 153               	.LC4:
 154 000d 2020 00   		.string	"  "
 155               		.text
 156               		.stabs	"MENU_Home:F(0,15)",36,0,289,MENU_Home
 157               	.global	MENU_Home
 158               		.type	MENU_Home, @function
 159               	MENU_Home:
 160               		.stabd	46,0,0
 287:rev2.c        **** }
 288:rev2.c        **** 
 289:rev2.c        **** void MENU_Home(void)
 290:rev2.c        **** {
 161               		.stabn	68,0,290,.LM10-.LFBB2
 162               	.LM10:
 163               	.LFBB2:
 164               	/* prologue: function */
 165               	/* frame size = 0 */
GAS LISTING /tmp/cccvrElj.s 			page 9


 166               	/* stack size = 0 */
 167               	.L__stack_usage = 0
 291:rev2.c        **** 	// Write normal home screen
 292:rev2.c        **** 	LCD_Clear();
 168               		.stabn	68,0,292,.LM11-.LFBB2
 169               	.LM11:
 170 002a 00D0      		rcall LCD_Clear
 293:rev2.c        **** 	LCD_Cursor(0,0);
 171               		.stabn	68,0,293,.LM12-.LFBB2
 172               	.LM12:
 173 002c 60E0      		ldi r22,0
 174 002e 80E0      		ldi r24,0
 175 0030 00D0      		rcall LCD_Cursor
 294:rev2.c        **** 	LCD_Write("V: ");
 176               		.stabn	68,0,294,.LM13-.LFBB2
 177               	.LM13:
 178 0032 80E0      		ldi r24,lo8(.LC0)
 179 0034 90E0      		ldi r25,hi8(.LC0)
 180 0036 00D0      		rcall LCD_Write
 295:rev2.c        **** 	LCD_Cursor(1,0);
 181               		.stabn	68,0,295,.LM14-.LFBB2
 182               	.LM14:
 183 0038 60E0      		ldi r22,0
 184 003a 81E0      		ldi r24,lo8(1)
 185 003c 00D0      		rcall LCD_Cursor
 296:rev2.c        **** 	LCD_Write("I: ");
 186               		.stabn	68,0,296,.LM15-.LFBB2
 187               	.LM15:
 188 003e 80E0      		ldi r24,lo8(.LC1)
 189 0040 90E0      		ldi r25,hi8(.LC1)
 190 0042 00D0      		rcall LCD_Write
 297:rev2.c        **** 
 298:rev2.c        **** 	// Determine the last selected encoder function
 299:rev2.c        **** 	switch(encoderControls)
 191               		.stabn	68,0,299,.LM16-.LFBB2
 192               	.LM16:
 193 0044 8091 0000 		lds r24,encoderControls
 194 0048 8130      		cpi r24,lo8(1)
 195 004a 01F0      		breq .L13
 196 004c 8230      		cpi r24,lo8(2)
 197 004e 01F4      		brne .L12
 300:rev2.c        **** 	{
 301:rev2.c        **** 	case VOLTAGE:
 302:rev2.c        **** 		LCD_Cursor(0,2);
 303:rev2.c        **** 		LCD_Write("~");
 304:rev2.c        **** 		break;
 305:rev2.c        **** 	case CURRENT:
 306:rev2.c        **** 		LCD_Cursor(1,2);
 198               		.stabn	68,0,306,.LM17-.LFBB2
 199               	.LM17:
 200 0050 62E0      		ldi r22,lo8(2)
 201 0052 81E0      		ldi r24,lo8(1)
 202 0054 00C0      		rjmp .L14
 203               	.L12:
 307:rev2.c        **** 		LCD_Write("~");
 308:rev2.c        **** 		break;
 309:rev2.c        **** 	default:
GAS LISTING /tmp/cccvrElj.s 			page 10


 310:rev2.c        **** 		encoderControls = VOLTAGE;
 204               		.stabn	68,0,310,.LM18-.LFBB2
 205               	.LM18:
 206 0056 81E0      		ldi r24,lo8(1)
 207 0058 8093 0000 		sts encoderControls,r24
 208               	.L13:
 311:rev2.c        **** 		LCD_Cursor(0,2);
 209               		.stabn	68,0,311,.LM19-.LFBB2
 210               	.LM19:
 211 005c 62E0      		ldi r22,lo8(2)
 212 005e 80E0      		ldi r24,0
 213               	.L14:
 214 0060 00D0      		rcall LCD_Cursor
 312:rev2.c        **** 		LCD_Write("~");
 215               		.stabn	68,0,312,.LM20-.LFBB2
 216               	.LM20:
 217 0062 80E0      		ldi r24,lo8(.LC2)
 218 0064 90E0      		ldi r25,hi8(.LC2)
 219 0066 00D0      		rcall LCD_Write
 313:rev2.c        **** 		break;
 314:rev2.c        **** 	}
 315:rev2.c        **** 
 316:rev2.c        **** 	if(OUTPUT_IS_ENABLED)
 317:rev2.c        **** 	{
 318:rev2.c        **** 		LCD_Cursor(0,14);
 220               		.stabn	68,0,318,.LM21-.LFBB2
 221               	.LM21:
 222 0068 6EE0      		ldi r22,lo8(14)
 223 006a 80E0      		ldi r24,0
 316:rev2.c        **** 	if(OUTPUT_IS_ENABLED)
 224               		.stabn	68,0,316,.LM22-.LFBB2
 225               	.LM22:
 226 006c C09B      		sbis 0x18,0
 227 006e 00C0      		rjmp .L11
 228               		.stabn	68,0,318,.LM23-.LFBB2
 229               	.LM23:
 230 0070 00D0      		rcall LCD_Cursor
 319:rev2.c        **** 		LCD_Write("ON");
 231               		.stabn	68,0,319,.LM24-.LFBB2
 232               	.LM24:
 233 0072 80E0      		ldi r24,lo8(.LC3)
 234 0074 90E0      		ldi r25,hi8(.LC3)
 235 0076 00C0      		rjmp .L15
 236               	.L11:
 320:rev2.c        **** 	}
 321:rev2.c        **** 	else
 322:rev2.c        **** 	{
 323:rev2.c        **** 		LCD_Cursor(0,14);
 237               		.stabn	68,0,323,.LM25-.LFBB2
 238               	.LM25:
 239 0078 00D0      		rcall LCD_Cursor
 324:rev2.c        **** 		LCD_Write("  ");
 240               		.stabn	68,0,324,.LM26-.LFBB2
 241               	.LM26:
 242 007a 80E0      		ldi r24,lo8(.LC4)
 243 007c 90E0      		ldi r25,hi8(.LC4)
 244               	.L15:
GAS LISTING /tmp/cccvrElj.s 			page 11


 245 007e 00C0      		rjmp LCD_Write
 246               		.size	MENU_Home, .-MENU_Home
 247               	.Lscope2:
 248               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 249               		.stabd	78,0,0
 250               		.section	.rodata.str1.1
 251               	.LC5:
 252 0010 4261 636B 		.string	"Backlight"
 252      6C69 6768 
 252      7400 
 253               	.LC6:
 254 001a 5B20 2020 		.string	"[              ]"
 254      2020 2020 
 254      2020 2020 
 254      2020 205D 
 254      00
 255               	.LC7:
 256 002b 3D00      		.string	"="
 257               	.LC8:
 258 002d 3E00      		.string	">"
 259               		.text
 260               		.stabs	"MENU_Backlight:F(0,15)",36,0,329,MENU_Backlight
 261               	.global	MENU_Backlight
 262               		.type	MENU_Backlight, @function
 263               	MENU_Backlight:
 264               		.stabd	46,0,0
 325:rev2.c        **** 	}
 326:rev2.c        **** 
 327:rev2.c        **** }
 328:rev2.c        **** 
 329:rev2.c        **** void MENU_Backlight(void)
 330:rev2.c        **** {
 265               		.stabn	68,0,330,.LM27-.LFBB3
 266               	.LM27:
 267               	.LFBB3:
 268 0080 CF93      		push r28
 269 0082 DF93      		push r29
 270               	/* prologue: function */
 271               	/* frame size = 0 */
 272               	/* stack size = 2 */
 273               	.L__stack_usage = 2
 331:rev2.c        **** 	// Write small backlight screen
 332:rev2.c        **** 	LCD_Clear();
 274               		.stabn	68,0,332,.LM28-.LFBB3
 275               	.LM28:
 276 0084 00D0      		rcall LCD_Clear
 333:rev2.c        **** 	LCD_Cursor(0,3);
 277               		.stabn	68,0,333,.LM29-.LFBB3
 278               	.LM29:
 279 0086 63E0      		ldi r22,lo8(3)
 280 0088 80E0      		ldi r24,0
 281 008a 00D0      		rcall LCD_Cursor
 334:rev2.c        **** 	LCD_Write("Backlight");
 282               		.stabn	68,0,334,.LM30-.LFBB3
 283               	.LM30:
 284 008c 80E0      		ldi r24,lo8(.LC5)
 285 008e 90E0      		ldi r25,hi8(.LC5)
GAS LISTING /tmp/cccvrElj.s 			page 12


 286 0090 00D0      		rcall LCD_Write
 335:rev2.c        **** 	LCD_Cursor(1,0);
 287               		.stabn	68,0,335,.LM31-.LFBB3
 288               	.LM31:
 289 0092 60E0      		ldi r22,0
 290 0094 81E0      		ldi r24,lo8(1)
 291 0096 00D0      		rcall LCD_Cursor
 336:rev2.c        **** 	LCD_Write("[              ]");
 292               		.stabn	68,0,336,.LM32-.LFBB3
 293               	.LM32:
 294 0098 80E0      		ldi r24,lo8(.LC6)
 295 009a 90E0      		ldi r25,hi8(.LC6)
 296 009c 00D0      		rcall LCD_Write
 337:rev2.c        **** 	LCD_Cursor(1,1);
 297               		.stabn	68,0,337,.LM33-.LFBB3
 298               	.LM33:
 299 009e 61E0      		ldi r22,lo8(1)
 300 00a0 81E0      		ldi r24,lo8(1)
 301 00a2 00D0      		rcall LCD_Cursor
 338:rev2.c        **** 	uint8_t i = backlight;
 302               		.stabn	68,0,338,.LM34-.LFBB3
 303               	.LM34:
 304 00a4 C091 0000 		lds r28,backlight
 339:rev2.c        **** 	for(i; i>0; i--)
 305               		.stabn	68,0,339,.LM35-.LFBB3
 306               	.LM35:
 307 00a8 00C0      		rjmp .L17
 308               	.L18:
 340:rev2.c        **** 	{
 341:rev2.c        **** 		LCD_Write("=");
 309               		.stabn	68,0,341,.LM36-.LFBB3
 310               	.LM36:
 311 00aa 80E0      		ldi r24,lo8(.LC7)
 312 00ac 90E0      		ldi r25,hi8(.LC7)
 313 00ae 00D0      		rcall LCD_Write
 339:rev2.c        **** 	for(i; i>0; i--)
 314               		.stabn	68,0,339,.LM37-.LFBB3
 315               	.LM37:
 316 00b0 C150      		subi r28,lo8(-(-1))
 317               	.L17:
 339:rev2.c        **** 	for(i; i>0; i--)
 318               		.stabn	68,0,339,.LM38-.LFBB3
 319               	.LM38:
 320 00b2 C111      		cpse r28,__zero_reg__
 321 00b4 00C0      		rjmp .L18
 342:rev2.c        **** 	}
 343:rev2.c        **** 	LCD_Write(">");
 322               		.stabn	68,0,343,.LM39-.LFBB3
 323               	.LM39:
 324 00b6 80E0      		ldi r24,lo8(.LC8)
 325 00b8 90E0      		ldi r25,hi8(.LC8)
 326 00ba 00D0      		rcall LCD_Write
 327               	.LBB5:
 344:rev2.c        **** 	while(!SW_Check1() && !SW_Check2() && !SW_Check3() && !SW_Check4())
 345:rev2.c        **** 	{
 346:rev2.c        **** 		unsigned char dir = SW_CheckEncoder();
 347:rev2.c        **** 		if(dir)
GAS LISTING /tmp/cccvrElj.s 			page 13


 348:rev2.c        **** 		{
 349:rev2.c        **** 			if(dir == ENCODER_CW) 	backlight += 1; 
 350:rev2.c        **** 			else					backlight -= 1;
 351:rev2.c        **** 			if(backlight > 20)
 352:rev2.c        **** 				backlight = 0;
 353:rev2.c        **** 			else if(backlight > 13)
 354:rev2.c        **** 				backlight = 13;
 328               		.stabn	68,0,354,.LM40-.LFBB3
 329               	.LM40:
 330 00bc DDE0      		ldi r29,lo8(13)
 331               	.LBE5:
 344:rev2.c        **** 	while(!SW_Check1() && !SW_Check2() && !SW_Check3() && !SW_Check4())
 332               		.stabn	68,0,344,.LM41-.LFBB3
 333               	.LM41:
 334 00be 00C0      		rjmp .L36
 335               	.L30:
 336               	.LBB6:
 346:rev2.c        **** 		unsigned char dir = SW_CheckEncoder();
 337               		.stabn	68,0,346,.LM42-.LFBB3
 338               	.LM42:
 339 00c0 00D0      		rcall SW_CheckEncoder
 347:rev2.c        **** 		if(dir)
 340               		.stabn	68,0,347,.LM43-.LFBB3
 341               	.LM43:
 342 00c2 8823      		tst r24
 343 00c4 01F0      		breq .L36
 344 00c6 9091 0000 		lds r25,backlight
 349:rev2.c        **** 			if(dir == ENCODER_CW) 	backlight += 1; 
 345               		.stabn	68,0,349,.LM44-.LFBB3
 346               	.LM44:
 347 00ca 8031      		cpi r24,lo8(16)
 348 00cc 01F4      		brne .L21
 349:rev2.c        **** 			if(dir == ENCODER_CW) 	backlight += 1; 
 349               		.stabn	68,0,349,.LM45-.LFBB3
 350               	.LM45:
 351 00ce 9F5F      		subi r25,lo8(-(1))
 352 00d0 00C0      		rjmp .L37
 353               	.L21:
 350:rev2.c        **** 			else					backlight -= 1;
 354               		.stabn	68,0,350,.LM46-.LFBB3
 355               	.LM46:
 356 00d2 9150      		subi r25,lo8(-(-1))
 357               	.L37:
 358 00d4 9093 0000 		sts backlight,r25
 351:rev2.c        **** 			if(backlight > 20)
 359               		.stabn	68,0,351,.LM47-.LFBB3
 360               	.LM47:
 361 00d8 8091 0000 		lds r24,backlight
 362 00dc 8531      		cpi r24,lo8(21)
 363 00de 00F0      		brlo .L23
 352:rev2.c        **** 				backlight = 0;
 364               		.stabn	68,0,352,.LM48-.LFBB3
 365               	.LM48:
 366 00e0 1092 0000 		sts backlight,__zero_reg__
 367 00e4 00C0      		rjmp .L36
 368               	.L23:
 353:rev2.c        **** 			else if(backlight > 13)
GAS LISTING /tmp/cccvrElj.s 			page 14


 369               		.stabn	68,0,353,.LM49-.LFBB3
 370               	.LM49:
 371 00e6 8E30      		cpi r24,lo8(14)
 372 00e8 00F0      		brlo .L25
 373               		.stabn	68,0,354,.LM50-.LFBB3
 374               	.LM50:
 375 00ea D093 0000 		sts backlight,r29
 376 00ee 00C0      		rjmp .L36
 377               	.L25:
 355:rev2.c        **** 			else
 356:rev2.c        **** 			{
 357:rev2.c        **** 				OCR1B = 19*backlight;
 378               		.stabn	68,0,357,.LM51-.LFBB3
 379               	.LM51:
 380 00f0 23E1      		ldi r18,lo8(19)
 381 00f2 829F      		mul r24,r18
 382 00f4 C001      		movw r24,r0
 383 00f6 1124      		clr __zero_reg__
 384 00f8 99BD      		out 0x28+1,r25
 385 00fa 88BD      		out 0x28,r24
 358:rev2.c        **** 				LCD_Cursor(1,0);
 386               		.stabn	68,0,358,.LM52-.LFBB3
 387               	.LM52:
 388 00fc 60E0      		ldi r22,0
 389 00fe 81E0      		ldi r24,lo8(1)
 390 0100 00D0      		rcall LCD_Cursor
 359:rev2.c        **** 				LCD_Write("[              ]");
 391               		.stabn	68,0,359,.LM53-.LFBB3
 392               	.LM53:
 393 0102 80E0      		ldi r24,lo8(.LC6)
 394 0104 90E0      		ldi r25,hi8(.LC6)
 395 0106 00D0      		rcall LCD_Write
 360:rev2.c        **** 				LCD_Cursor(1,1);
 396               		.stabn	68,0,360,.LM54-.LFBB3
 397               	.LM54:
 398 0108 61E0      		ldi r22,lo8(1)
 399 010a 81E0      		ldi r24,lo8(1)
 400 010c 00D0      		rcall LCD_Cursor
 361:rev2.c        **** 				for(i = backlight; i>0; i--)
 401               		.stabn	68,0,361,.LM55-.LFBB3
 402               	.LM55:
 403 010e C091 0000 		lds r28,backlight
 404 0112 00C0      		rjmp .L26
 405               	.L27:
 362:rev2.c        **** 				{
 363:rev2.c        **** 					LCD_Write("=");
 406               		.stabn	68,0,363,.LM56-.LFBB3
 407               	.LM56:
 408 0114 80E0      		ldi r24,lo8(.LC7)
 409 0116 90E0      		ldi r25,hi8(.LC7)
 410 0118 00D0      		rcall LCD_Write
 361:rev2.c        **** 				for(i = backlight; i>0; i--)
 411               		.stabn	68,0,361,.LM57-.LFBB3
 412               	.LM57:
 413 011a C150      		subi r28,lo8(-(-1))
 414               	.L26:
 361:rev2.c        **** 				for(i = backlight; i>0; i--)
GAS LISTING /tmp/cccvrElj.s 			page 15


 415               		.stabn	68,0,361,.LM58-.LFBB3
 416               	.LM58:
 417 011c C111      		cpse r28,__zero_reg__
 418 011e 00C0      		rjmp .L27
 364:rev2.c        **** 				}
 365:rev2.c        **** 				LCD_Write(">");
 419               		.stabn	68,0,365,.LM59-.LFBB3
 420               	.LM59:
 421 0120 80E0      		ldi r24,lo8(.LC8)
 422 0122 90E0      		ldi r25,hi8(.LC8)
 423 0124 00D0      		rcall LCD_Write
 424               	.L36:
 425               	.LBE6:
 344:rev2.c        **** 	while(!SW_Check1() && !SW_Check2() && !SW_Check3() && !SW_Check4())
 426               		.stabn	68,0,344,.LM60-.LFBB3
 427               	.LM60:
 428 0126 00D0      		rcall SW_Check1
 429 0128 8111      		cpse r24,__zero_reg__
 430 012a 00C0      		rjmp .L16
 344:rev2.c        **** 	while(!SW_Check1() && !SW_Check2() && !SW_Check3() && !SW_Check4())
 431               		.stabn	68,0,344,.LM61-.LFBB3
 432               	.LM61:
 433 012c 00D0      		rcall SW_Check2
 434 012e 8111      		cpse r24,__zero_reg__
 435 0130 00C0      		rjmp .L16
 344:rev2.c        **** 	while(!SW_Check1() && !SW_Check2() && !SW_Check3() && !SW_Check4())
 436               		.stabn	68,0,344,.LM62-.LFBB3
 437               	.LM62:
 438 0132 00D0      		rcall SW_Check3
 439 0134 8111      		cpse r24,__zero_reg__
 440 0136 00C0      		rjmp .L16
 441 0138 00D0      		rcall SW_Check4
 442 013a 8823      		tst r24
 443 013c 01F0      		breq .L30
 444               	.L16:
 445               	/* epilogue start */
 366:rev2.c        **** 			}
 367:rev2.c        **** 		}
 368:rev2.c        **** 	}
 369:rev2.c        **** }
 446               		.stabn	68,0,369,.LM63-.LFBB3
 447               	.LM63:
 448 013e DF91      		pop r29
 449 0140 CF91      		pop r28
 450 0142 0895      		ret
 451               		.size	MENU_Backlight, .-MENU_Backlight
 452               		.stabs	"dir:r(0,11)",64,0,346,24
 453               		.stabn	192,0,0,.LBB5-.LFBB3
 454               		.stabn	224,0,0,.LBE5-.LFBB3
 455               		.stabs	"dir:r(0,11)",64,0,346,24
 456               		.stabn	192,0,0,.LBB6-.LFBB3
 457               		.stabn	224,0,0,.LBE6-.LFBB3
 458               	.Lscope3:
 459               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 460               		.stabd	78,0,0
 461               		.section	.rodata.str1.1
 462               	.LC9:
GAS LISTING /tmp/cccvrElj.s 			page 16


 463 002f 6469 6769 		.string	"digital"
 463      7461 6C00 
 464               	.LC10:
 465 0037 5053 5500 		.string	"PSU"
 466               	.LC11:
 467 003b 2000      		.string	" "
 468               	.global	__floatunsisf
 469               	.global	__divsf3
 470               	.global	__fixunssfsi
 471               	.global	__mulsf3
 472               		.section	.text.startup,"ax",@progbits
 473               		.stabs	"main:F(0,1)",36,0,13,main
 474               	.global	main
 475               		.type	main, @function
 476               	main:
 477               		.stabd	46,0,0
  14:rev2.c        **** {
 478               		.stabn	68,0,14,.LM64-.LFBB4
 479               	.LM64:
 480               	.LFBB4:
 481               	/* prologue: function */
 482               	/* frame size = 0 */
 483               	/* stack size = 0 */
 484               	.L__stack_usage = 0
  15:rev2.c        **** 	DDRB = 0;
 485               		.stabn	68,0,15,.LM65-.LFBB4
 486               	.LM65:
 487 0000 17BA      		out 0x17,__zero_reg__
  16:rev2.c        **** 	DDRC = 0;
 488               		.stabn	68,0,16,.LM66-.LFBB4
 489               	.LM66:
 490 0002 14BA      		out 0x14,__zero_reg__
  17:rev2.c        **** 	DDRD = 0;
 491               		.stabn	68,0,17,.LM67-.LFBB4
 492               	.LM67:
 493 0004 11BA      		out 0x11,__zero_reg__
  20:rev2.c        **** 	SW_Initialize();
 494               		.stabn	68,0,20,.LM68-.LFBB4
 495               	.LM68:
 496 0006 00D0      		rcall SW_Initialize
  23:rev2.c        **** 	DDRD |= 1 << PD7;	// DAC chip select
 497               		.stabn	68,0,23,.LM69-.LFBB4
 498               	.LM69:
 499 0008 8F9A      		sbi 0x11,7
  24:rev2.c        **** 	DESELECT_DAC;
 500               		.stabn	68,0,24,.LM70-.LFBB4
 501               	.LM70:
 502 000a 979A      		sbi 0x12,7
  27:rev2.c        **** 	DDRB |= 1 << PB0;	// Output enable
 503               		.stabn	68,0,27,.LM71-.LFBB4
 504               	.LM71:
 505 000c B89A      		sbi 0x17,0
  28:rev2.c        **** 	DISABLE_OUTPUT;
 506               		.stabn	68,0,28,.LM72-.LFBB4
 507               	.LM72:
 508 000e C098      		cbi 0x18,0
  31:rev2.c        **** 	DDRB |= 1 << PB3;	// SPI MOSI
GAS LISTING /tmp/cccvrElj.s 			page 17


 509               		.stabn	68,0,31,.LM73-.LFBB4
 510               	.LM73:
 511 0010 BB9A      		sbi 0x17,3
  32:rev2.c        **** 	DDRB |= 1 << PB5;	// SPI SCK
 512               		.stabn	68,0,32,.LM74-.LFBB4
 513               	.LM74:
 514 0012 BD9A      		sbi 0x17,5
  34:rev2.c        **** 	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
 515               		.stabn	68,0,34,.LM75-.LFBB4
 516               	.LM75:
 517 0014 81E5      		ldi r24,lo8(81)
 518 0016 8DB9      		out 0xd,r24
  40:rev2.c        **** 	DDRB |= 1 << PB1;							// Charge pump
 519               		.stabn	68,0,40,.LM76-.LFBB4
 520               	.LM76:
 521 0018 B99A      		sbi 0x17,1
  41:rev2.c        **** 	DDRB |= 1 << PB2;							// Backlight
 522               		.stabn	68,0,41,.LM77-.LFBB4
 523               	.LM77:
 524 001a BA9A      		sbi 0x17,2
  42:rev2.c        **** 	TCCR1A  = (1 << COM1A1) | (1 << COM1B1);	// Enable both osc
 525               		.stabn	68,0,42,.LM78-.LFBB4
 526               	.LM78:
 527 001c 80EA      		ldi r24,lo8(-96)
 528 001e 8FBD      		out 0x2f,r24
  43:rev2.c        **** 	TCCR1A |= (1 << WGM10) | (1 << WGM12);		// FAST 8 bit PWM
 529               		.stabn	68,0,43,.LM79-.LFBB4
 530               	.LM79:
 531 0020 8FB5      		in r24,0x2f
 532 0022 8960      		ori r24,lo8(9)
 533 0024 8FBD      		out 0x2f,r24
  44:rev2.c        **** 	OCR1A = 0x80;								// charge pump 128
 534               		.stabn	68,0,44,.LM80-.LFBB4
 535               	.LM80:
 536 0026 80E8      		ldi r24,lo8(-128)
 537 0028 90E0      		ldi r25,0
 538 002a 9BBD      		out 0x2a+1,r25
 539 002c 8ABD      		out 0x2a,r24
  45:rev2.c        **** 	OCR1B = backlight*19;						// Backlight
 540               		.stabn	68,0,45,.LM81-.LFBB4
 541               	.LM81:
 542 002e 8091 0000 		lds r24,backlight
 543 0032 23E1      		ldi r18,lo8(19)
 544 0034 829F      		mul r24,r18
 545 0036 C001      		movw r24,r0
 546 0038 1124      		clr __zero_reg__
 547 003a 99BD      		out 0x28+1,r25
 548 003c 88BD      		out 0x28,r24
  46:rev2.c        **** 	TCCR1B = (1 << CS10);						// START no prescaler
 549               		.stabn	68,0,46,.LM82-.LFBB4
 550               	.LM82:
 551 003e 81E0      		ldi r24,lo8(1)
 552 0040 8EBD      		out 0x2e,r24
  49:rev2.c        **** 	LCD_Initialize();
 553               		.stabn	68,0,49,.LM83-.LFBB4
 554               	.LM83:
 555 0042 00D0      		rcall LCD_Initialize
GAS LISTING /tmp/cccvrElj.s 			page 18


  50:rev2.c        **** 	LCD_Cursor(0,4);
 556               		.stabn	68,0,50,.LM84-.LFBB4
 557               	.LM84:
 558 0044 64E0      		ldi r22,lo8(4)
 559 0046 80E0      		ldi r24,0
 560 0048 00D0      		rcall LCD_Cursor
  51:rev2.c        **** 	LCD_Write("digital");
 561               		.stabn	68,0,51,.LM85-.LFBB4
 562               	.LM85:
 563 004a 80E0      		ldi r24,lo8(.LC9)
 564 004c 90E0      		ldi r25,hi8(.LC9)
 565 004e 00D0      		rcall LCD_Write
  52:rev2.c        **** 	LCD_Cursor(1,6);
 566               		.stabn	68,0,52,.LM86-.LFBB4
 567               	.LM86:
 568 0050 66E0      		ldi r22,lo8(6)
 569 0052 81E0      		ldi r24,lo8(1)
 570 0054 00D0      		rcall LCD_Cursor
  53:rev2.c        **** 	LCD_Write("PSU");
 571               		.stabn	68,0,53,.LM87-.LFBB4
 572               	.LM87:
 573 0056 80E0      		ldi r24,lo8(.LC10)
 574 0058 90E0      		ldi r25,hi8(.LC10)
 575 005a 00D0      		rcall LCD_Write
 576               	.LBB7:
 577               	.LBB8:
 578               		.stabs	"/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h",132,0,0,.Ltext1
 579               	.Ltext1:
   1:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
GAS LISTING /tmp/cccvrElj.s 			page 19


  30:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
GAS LISTING /tmp/cccvrElj.s 			page 20


  87:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
 103:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 104:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /**
 105:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 109:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 112:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 120:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 129:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 132:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 140:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  */
 141:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** void
 142:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** {
GAS LISTING /tmp/cccvrElj.s 			page 21


 144:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 156:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 159:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 580               		.stabn	68,0,164,.LM88-.LFBB4
 581               	.LM88:
 582 005c 8FEF      		ldi r24,lo8(3199999)
 583 005e 93ED      		ldi r25,hi8(3199999)
 584 0060 20E3      		ldi r18,hlo8(3199999)
 585 0062 8150      		1: subi r24,1
 586 0064 9040      		sbci r25,0
 587 0066 2040      		sbci r18,0
 588 0068 01F4      		brne 1b
 589 006a 00C0      		rjmp .
 590 006c 0000      		nop
 591               	.LBE8:
 592               	.LBE7:
 593               		.stabs	"rev2.c",132,0,0,.Ltext2
 594               	.Ltext2:
  55:rev2.c        **** 	LCD_Clear();
 595               		.stabn	68,0,55,.LM89-.LFBB4
 596               	.LM89:
 597 006e 00D0      		rcall LCD_Clear
  86:rev2.c        **** 	ADC_initialize();
 598               		.stabn	68,0,86,.LM90-.LFBB4
 599               	.LM90:
 600 0070 00D0      		rcall ADC_initialize
  87:rev2.c        **** 	ADC_STARTCONVERSION;
 601               		.stabn	68,0,87,.LM91-.LFBB4
 602               	.LM91:
 603 0072 369A      		sbi 0x6,6
  88:rev2.c        **** 	sei();
 604               		.stabn	68,0,88,.LM92-.LFBB4
 605               	.LM92:
 606               	/* #APP */
 607               	 ;  88 "rev2.c" 1
 608 0074 7894      		sei
 609               	 ;  0 "" 2
  91:rev2.c        **** 	USART_Initialize();
 610               		.stabn	68,0,91,.LM93-.LFBB4
GAS LISTING /tmp/cccvrElj.s 			page 22


 611               	.LM93:
 612               	/* #NOAPP */
 613 0076 00D0      		rcall USART_Initialize
  93:rev2.c        **** 	MENU_Home();
 614               		.stabn	68,0,93,.LM94-.LFBB4
 615               	.LM94:
 616 0078 00D0      		rcall MENU_Home
  94:rev2.c        **** 	LCD_Cursor(0,3);
 617               		.stabn	68,0,94,.LM95-.LFBB4
 618               	.LM95:
 619 007a 63E0      		ldi r22,lo8(3)
 620 007c 80E0      		ldi r24,0
 621 007e 00D0      		rcall LCD_Cursor
  95:rev2.c        **** 	LCD_WriteFloat(voltageSet);
 622               		.stabn	68,0,95,.LM96-.LFBB4
 623               	.LM96:
 624 0080 80E0      		ldi r24,0
 625 0082 90E0      		ldi r25,0
 626 0084 00D0      		rcall LCD_WriteFloat
  96:rev2.c        **** 	LCD_Cursor(1,3);
 627               		.stabn	68,0,96,.LM97-.LFBB4
 628               	.LM97:
 629 0086 63E0      		ldi r22,lo8(3)
 630 0088 81E0      		ldi r24,lo8(1)
 631 008a 00D0      		rcall LCD_Cursor
  97:rev2.c        **** 	LCD_WriteFloat(currentSet);
 632               		.stabn	68,0,97,.LM98-.LFBB4
 633               	.LM98:
 634 008c 80E0      		ldi r24,0
 635 008e 90E0      		ldi r25,0
 636 0090 00D0      		rcall LCD_WriteFloat
  75:rev2.c        **** 	uint16_t currentSetDelay = 0;
 637               		.stabn	68,0,75,.LM99-.LFBB4
 638               	.LM99:
 639 0092 C12C      		mov r12,__zero_reg__
 640 0094 D12C      		mov r13,__zero_reg__
  74:rev2.c        **** 	uint16_t voltageSetDelay = 0;
 641               		.stabn	68,0,74,.LM100-.LFBB4
 642               	.LM100:
 643 0096 E12C      		mov r14,__zero_reg__
 644 0098 F12C      		mov r15,__zero_reg__
  69:rev2.c        **** 	uint16_t currentSet = 0;
 645               		.stabn	68,0,69,.LM101-.LFBB4
 646               	.LM101:
 647 009a 00E0      		ldi r16,0
 648 009c 10E0      		ldi r17,0
  68:rev2.c        **** 	uint16_t voltageSet = 0;
 649               		.stabn	68,0,68,.LM102-.LFBB4
 650               	.LM102:
 651 009e C0E0      		ldi r28,0
 652 00a0 D0E0      		ldi r29,0
 653               	.LBB9:
 142:rev2.c        **** 				encoderControls = CURRENT;
 654               		.stabn	68,0,142,.LM103-.LFBB4
 655               	.LM103:
 656 00a2 42E0      		ldi r20,lo8(2)
 657 00a4 742E      		mov r7,r20
GAS LISTING /tmp/cccvrElj.s 			page 23


 234:rev2.c        **** 				ADC_status = ADC_PREREGULATOR;
 658               		.stabn	68,0,234,.LM104-.LFBB4
 659               	.LM104:
 660 00a6 54E0      		ldi r21,lo8(4)
 661 00a8 652E      		mov r6,r21
 245:rev2.c        **** 				ADC_status = ADC_VIN;
 662               		.stabn	68,0,245,.LM105-.LFBB4
 663               	.LM105:
 664 00aa 68E0      		ldi r22,lo8(8)
 665 00ac 562E      		mov r5,r22
 666               	.L96:
 108:rev2.c        **** 		if (SW_Check1())
 667               		.stabn	68,0,108,.LM106-.LFBB4
 668               	.LM106:
 669 00ae 00D0      		rcall SW_Check1
 670 00b0 8823      		tst r24
 671 00b2 01F0      		breq .L40
 110:rev2.c        **** 			if(OUTPUT_IS_ENABLED)
 672               		.stabn	68,0,110,.LM107-.LFBB4
 673               	.LM107:
 674 00b4 C09B      		sbis 0x18,0
 675 00b6 00C0      		rjmp .L41
 112:rev2.c        **** 				DISABLE_OUTPUT;
 676               		.stabn	68,0,112,.LM108-.LFBB4
 677               	.LM108:
 678 00b8 C098      		cbi 0x18,0
 113:rev2.c        **** 				LCD_Cursor(0,14);
 679               		.stabn	68,0,113,.LM109-.LFBB4
 680               	.LM109:
 681 00ba 6EE0      		ldi r22,lo8(14)
 682 00bc 80E0      		ldi r24,0
 683 00be 00D0      		rcall LCD_Cursor
 114:rev2.c        **** 				LCD_Write("  ");
 684               		.stabn	68,0,114,.LM110-.LFBB4
 685               	.LM110:
 686 00c0 80E0      		ldi r24,lo8(.LC4)
 687 00c2 90E0      		ldi r25,hi8(.LC4)
 688 00c4 00C0      		rjmp .L98
 689               	.L41:
 118:rev2.c        **** 				ENABLE_OUTPUT;
 690               		.stabn	68,0,118,.LM111-.LFBB4
 691               	.LM111:
 692 00c6 C09A      		sbi 0x18,0
 119:rev2.c        **** 				LCD_Cursor(0,14);
 693               		.stabn	68,0,119,.LM112-.LFBB4
 694               	.LM112:
 695 00c8 6EE0      		ldi r22,lo8(14)
 696 00ca 80E0      		ldi r24,0
 697 00cc 00D0      		rcall LCD_Cursor
 120:rev2.c        **** 				LCD_Write("ON");
 698               		.stabn	68,0,120,.LM113-.LFBB4
 699               	.LM113:
 700 00ce 80E0      		ldi r24,lo8(.LC3)
 701 00d0 90E0      		ldi r25,hi8(.LC3)
 702               	.L98:
 703 00d2 00D0      		rcall LCD_Write
 704               	.L40:
GAS LISTING /tmp/cccvrElj.s 			page 24


 125:rev2.c        **** 		if (SW_Check2())
 705               		.stabn	68,0,125,.LM114-.LFBB4
 706               	.LM114:
 707 00d4 00D0      		rcall SW_Check2
 708 00d6 8823      		tst r24
 709 00d8 01F0      		breq .L42
 128:rev2.c        **** 			MENU_Backlight();
 710               		.stabn	68,0,128,.LM115-.LFBB4
 711               	.LM115:
 712 00da 00D0      		rcall MENU_Backlight
 129:rev2.c        **** 			MENU_Home();
 713               		.stabn	68,0,129,.LM116-.LFBB4
 714               	.LM116:
 715 00dc 00D0      		rcall MENU_Home
 130:rev2.c        **** 			LCD_Cursor(0,3);
 716               		.stabn	68,0,130,.LM117-.LFBB4
 717               	.LM117:
 718 00de 63E0      		ldi r22,lo8(3)
 719 00e0 80E0      		ldi r24,0
 720 00e2 00D0      		rcall LCD_Cursor
 131:rev2.c        **** 			LCD_WriteFloat(voltageSet);
 721               		.stabn	68,0,131,.LM118-.LFBB4
 722               	.LM118:
 723 00e4 CE01      		movw r24,r28
 724 00e6 00D0      		rcall LCD_WriteFloat
 132:rev2.c        **** 			LCD_Cursor(1,3);
 725               		.stabn	68,0,132,.LM119-.LFBB4
 726               	.LM119:
 727 00e8 63E0      		ldi r22,lo8(3)
 728 00ea 81E0      		ldi r24,lo8(1)
 729 00ec 00D0      		rcall LCD_Cursor
 133:rev2.c        **** 			LCD_WriteFloat(currentSet);
 730               		.stabn	68,0,133,.LM120-.LFBB4
 731               	.LM120:
 732 00ee C801      		movw r24,r16
 733 00f0 00D0      		rcall LCD_WriteFloat
 734               	.L42:
 137:rev2.c        **** 		if (SW_Check4())
 735               		.stabn	68,0,137,.LM121-.LFBB4
 736               	.LM121:
 737 00f2 00D0      		rcall SW_Check4
 738 00f4 8823      		tst r24
 739 00f6 01F0      		breq .L43
 139:rev2.c        **** 			switch(encoderControls)
 740               		.stabn	68,0,139,.LM122-.LFBB4
 741               	.LM122:
 742 00f8 8091 0000 		lds r24,encoderControls
 743 00fc 8130      		cpi r24,lo8(1)
 744 00fe 01F0      		breq .L45
 745 0100 00C0      		rjmp .L97
 746               	.L45:
 142:rev2.c        **** 				encoderControls = CURRENT;
 747               		.stabn	68,0,142,.LM123-.LFBB4
 748               	.LM123:
 749 0102 7092 0000 		sts encoderControls,r7
 143:rev2.c        **** 				LCD_Cursor(0,2);
 750               		.stabn	68,0,143,.LM124-.LFBB4
GAS LISTING /tmp/cccvrElj.s 			page 25


 751               	.LM124:
 752 0106 62E0      		ldi r22,lo8(2)
 753 0108 80E0      		ldi r24,0
 754 010a 00D0      		rcall LCD_Cursor
 144:rev2.c        **** 				LCD_Write(" ");
 755               		.stabn	68,0,144,.LM125-.LFBB4
 756               	.LM125:
 757 010c 80E0      		ldi r24,lo8(.LC11)
 758 010e 90E0      		ldi r25,hi8(.LC11)
 759 0110 00D0      		rcall LCD_Write
 145:rev2.c        **** 				LCD_Cursor(1,2);
 760               		.stabn	68,0,145,.LM126-.LFBB4
 761               	.LM126:
 762 0112 62E0      		ldi r22,lo8(2)
 763 0114 81E0      		ldi r24,lo8(1)
 764 0116 00D0      		rcall LCD_Cursor
 146:rev2.c        **** 				LCD_Write("~");
 765               		.stabn	68,0,146,.LM127-.LFBB4
 766               	.LM127:
 767 0118 80E0      		ldi r24,lo8(.LC2)
 768 011a 90E0      		ldi r25,hi8(.LC2)
 769 011c 00C0      		rjmp .L99
 770               	.L97:
 156:rev2.c        **** 				encoderControls = VOLTAGE;
 771               		.stabn	68,0,156,.LM128-.LFBB4
 772               	.LM128:
 773 011e 81E0      		ldi r24,lo8(1)
 774 0120 8093 0000 		sts encoderControls,r24
 157:rev2.c        **** 				LCD_Cursor(0,2);
 775               		.stabn	68,0,157,.LM129-.LFBB4
 776               	.LM129:
 777 0124 62E0      		ldi r22,lo8(2)
 778 0126 80E0      		ldi r24,0
 779 0128 00D0      		rcall LCD_Cursor
 158:rev2.c        **** 				LCD_Write("~");
 780               		.stabn	68,0,158,.LM130-.LFBB4
 781               	.LM130:
 782 012a 80E0      		ldi r24,lo8(.LC2)
 783 012c 90E0      		ldi r25,hi8(.LC2)
 784 012e 00D0      		rcall LCD_Write
 159:rev2.c        **** 				LCD_Cursor(1,2);
 785               		.stabn	68,0,159,.LM131-.LFBB4
 786               	.LM131:
 787 0130 62E0      		ldi r22,lo8(2)
 788 0132 81E0      		ldi r24,lo8(1)
 789 0134 00D0      		rcall LCD_Cursor
 160:rev2.c        **** 				LCD_Write(" ");
 790               		.stabn	68,0,160,.LM132-.LFBB4
 791               	.LM132:
 792 0136 80E0      		ldi r24,lo8(.LC11)
 793 0138 90E0      		ldi r25,hi8(.LC11)
 794               	.L99:
 795 013a 00D0      		rcall LCD_Write
 796               	.L43:
 167:rev2.c        **** 		unsigned char dir = SW_CheckEncoder();
 797               		.stabn	68,0,167,.LM133-.LFBB4
 798               	.LM133:
GAS LISTING /tmp/cccvrElj.s 			page 26


 799 013c 00D0      		rcall SW_CheckEncoder
 168:rev2.c        **** 		if(dir)
 800               		.stabn	68,0,168,.LM134-.LFBB4
 801               	.LM134:
 802 013e 8823      		tst r24
 803 0140 01F4      		brne .+2
 804 0142 00C0      		rjmp .L47
 170:rev2.c        **** 			switch(encoderControls)
 805               		.stabn	68,0,170,.LM135-.LFBB4
 806               	.LM135:
 807 0144 9091 0000 		lds r25,encoderControls
 808 0148 9130      		cpi r25,lo8(1)
 809 014a 01F0      		breq .L48
 810 014c 9230      		cpi r25,lo8(2)
 811 014e 01F0      		breq .+2
 812 0150 00C0      		rjmp .L47
 813 0152 00C0      		rjmp .L49
 814               	.L48:
 173:rev2.c        **** 				if(dir == ENCODER_CW)	voltageSet += 2;
 815               		.stabn	68,0,173,.LM136-.LFBB4
 816               	.LM136:
 817 0154 8031      		cpi r24,lo8(16)
 818 0156 01F4      		brne .L50
 173:rev2.c        **** 				if(dir == ENCODER_CW)	voltageSet += 2;
 819               		.stabn	68,0,173,.LM137-.LFBB4
 820               	.LM137:
 821 0158 2296      		adiw r28,2
 822 015a 00C0      		rjmp .L51
 823               	.L50:
 174:rev2.c        **** 				else 					voltageSet -= 2;
 824               		.stabn	68,0,174,.LM138-.LFBB4
 825               	.LM138:
 826 015c 2297      		sbiw r28,2
 827               	.L51:
 176:rev2.c        **** 				if(voltageSet > 60000)
 828               		.stabn	68,0,176,.LM139-.LFBB4
 829               	.LM139:
 830 015e C136      		cpi r28,97
 831 0160 8AEE      		ldi r24,-22
 832 0162 D807      		cpc r29,r24
 833 0164 00F4      		brsh .L71
 834 0166 C13D      		cpi r28,-47
 835 0168 97E0      		ldi r25,7
 836 016a D907      		cpc r29,r25
 837 016c 00F0      		brlo .L52
 838 016e C0ED      		ldi r28,lo8(-48)
 839 0170 D7E0      		ldi r29,lo8(7)
 840 0172 00C0      		rjmp .L52
 841               	.L71:
 177:rev2.c        **** 					voltageSet = 0;
 842               		.stabn	68,0,177,.LM140-.LFBB4
 843               	.LM140:
 844 0174 C0E0      		ldi r28,0
 845 0176 D0E0      		ldi r29,0
 846               	.L52:
 181:rev2.c        **** 				transferToDAC(9,voltageSet/voltageSetMulti);
 847               		.stabn	68,0,181,.LM141-.LFBB4
GAS LISTING /tmp/cccvrElj.s 			page 27


 848               	.LM141:
 849 0178 BE01      		movw r22,r28
 850 017a 80E0      		ldi r24,0
 851 017c 90E0      		ldi r25,0
 852 017e 00D0      		rcall __floatunsisf
 853 0180 22EC      		ldi r18,lo8(-62)
 854 0182 35E8      		ldi r19,lo8(-123)
 855 0184 42E1      		ldi r20,lo8(18)
 856 0186 50E4      		ldi r21,lo8(64)
 857 0188 00D0      		rcall __divsf3
 858 018a 00D0      		rcall __fixunssfsi
 859 018c 89E0      		ldi r24,lo8(9)
 860 018e 00D0      		rcall transferToDAC
 182:rev2.c        **** 				LCD_Cursor(0,3);
 861               		.stabn	68,0,182,.LM142-.LFBB4
 862               	.LM142:
 863 0190 63E0      		ldi r22,lo8(3)
 864 0192 80E0      		ldi r24,0
 865 0194 00D0      		rcall LCD_Cursor
 183:rev2.c        **** 				LCD_WriteFloat(voltageSet);
 866               		.stabn	68,0,183,.LM143-.LFBB4
 867               	.LM143:
 868 0196 CE01      		movw r24,r28
 869 0198 00D0      		rcall LCD_WriteFloat
 186:rev2.c        **** 				voltageSetDelay = numDelayCycles;
 870               		.stabn	68,0,186,.LM144-.LFBB4
 871               	.LM144:
 872 019a 38EB      		ldi r19,lo8(-72)
 873 019c E32E      		mov r14,r19
 874 019e 3BE0      		ldi r19,lo8(11)
 875 01a0 F32E      		mov r15,r19
 876 01a2 00C0      		rjmp .L54
 877               	.L49:
 189:rev2.c        **** 				if(dir == ENCODER_CW) 	currentSet += 1;
 878               		.stabn	68,0,189,.LM145-.LFBB4
 879               	.LM145:
 880 01a4 8031      		cpi r24,lo8(16)
 881 01a6 01F4      		brne .L55
 189:rev2.c        **** 				if(dir == ENCODER_CW) 	currentSet += 1;
 882               		.stabn	68,0,189,.LM146-.LFBB4
 883               	.LM146:
 884 01a8 0F5F      		subi r16,-1
 885 01aa 1F4F      		sbci r17,-1
 886 01ac 00C0      		rjmp .L56
 887               	.L55:
 190:rev2.c        **** 				else					currentSet -= 1;
 888               		.stabn	68,0,190,.LM147-.LFBB4
 889               	.LM147:
 890 01ae 0150      		subi r16,1
 891 01b0 1109      		sbc r17,__zero_reg__
 892               	.L56:
 192:rev2.c        **** 				if(currentSet > 60000)
 893               		.stabn	68,0,192,.LM148-.LFBB4
 894               	.LM148:
 895 01b2 0136      		cpi r16,97
 896 01b4 2AEE      		ldi r18,-22
 897 01b6 1207      		cpc r17,r18
GAS LISTING /tmp/cccvrElj.s 			page 28


 898 01b8 00F4      		brsh .L72
 899 01ba 0536      		cpi r16,101
 900 01bc 1105      		cpc r17,__zero_reg__
 901 01be 00F0      		brlo .L57
 902 01c0 04E6      		ldi r16,lo8(100)
 903 01c2 10E0      		ldi r17,0
 904 01c4 00C0      		rjmp .L57
 905               	.L72:
 193:rev2.c        **** 					currentSet = 0;
 906               		.stabn	68,0,193,.LM149-.LFBB4
 907               	.LM149:
 908 01c6 00E0      		ldi r16,0
 909 01c8 10E0      		ldi r17,0
 910               	.L57:
 197:rev2.c        **** 				transferToDAC(10,currentSet/currentSetMulti);
 911               		.stabn	68,0,197,.LM150-.LFBB4
 912               	.LM150:
 913 01ca B801      		movw r22,r16
 914 01cc 80E0      		ldi r24,0
 915 01ce 90E0      		ldi r25,0
 916 01d0 00D0      		rcall __floatunsisf
 917 01d2 24E1      		ldi r18,lo8(20)
 918 01d4 39E6      		ldi r19,lo8(105)
 919 01d6 49E0      		ldi r20,lo8(9)
 920 01d8 5EE3      		ldi r21,lo8(62)
 921 01da 00D0      		rcall __divsf3
 922 01dc 00D0      		rcall __fixunssfsi
 923 01de 8AE0      		ldi r24,lo8(10)
 924 01e0 00D0      		rcall transferToDAC
 198:rev2.c        **** 				LCD_Cursor(1,3);
 925               		.stabn	68,0,198,.LM151-.LFBB4
 926               	.LM151:
 927 01e2 63E0      		ldi r22,lo8(3)
 928 01e4 81E0      		ldi r24,lo8(1)
 929 01e6 00D0      		rcall LCD_Cursor
 199:rev2.c        **** 				LCD_WriteFloat(currentSet);
 930               		.stabn	68,0,199,.LM152-.LFBB4
 931               	.LM152:
 932 01e8 C801      		movw r24,r16
 933 01ea 00D0      		rcall LCD_WriteFloat
 200:rev2.c        **** 				currentSetDelay = numDelayCycles;
 934               		.stabn	68,0,200,.LM153-.LFBB4
 935               	.LM153:
 936 01ec 28EB      		ldi r18,lo8(-72)
 937 01ee C22E      		mov r12,r18
 938 01f0 2BE0      		ldi r18,lo8(11)
 939 01f2 D22E      		mov r13,r18
 940               	.L47:
 208:rev2.c        **** 		if (voltageSetDelay > 0)
 941               		.stabn	68,0,208,.LM154-.LFBB4
 942               	.LM154:
 943 01f4 E114      		cp r14,__zero_reg__
 944 01f6 F104      		cpc r15,__zero_reg__
 945 01f8 01F0      		breq .L59
 946               	.L54:
 209:rev2.c        **** 			voltageSetDelay--;
 947               		.stabn	68,0,209,.LM155-.LFBB4
GAS LISTING /tmp/cccvrElj.s 			page 29


 948               	.LM155:
 949 01fa 81E0      		ldi r24,1
 950 01fc E81A      		sub r14,r24
 951 01fe F108      		sbc r15,__zero_reg__
 952               	.L59:
 210:rev2.c        **** 		if (currentSetDelay > 0)
 953               		.stabn	68,0,210,.LM156-.LFBB4
 954               	.LM156:
 955 0200 C114      		cp r12,__zero_reg__
 956 0202 D104      		cpc r13,__zero_reg__
 957 0204 01F0      		breq .L60
 211:rev2.c        **** 			currentSetDelay--;
 958               		.stabn	68,0,211,.LM157-.LFBB4
 959               	.LM157:
 960 0206 91E0      		ldi r25,1
 961 0208 C91A      		sub r12,r25
 962 020a D108      		sbc r13,__zero_reg__
 963               	.L60:
 214:rev2.c        **** 		if(ADC_status & ADC_NEWREADING)
 964               		.stabn	68,0,214,.LM158-.LFBB4
 965               	.LM158:
 966 020c 8091 0000 		lds r24,ADC_status
 967 0210 86FF      		sbrs r24,6
 968 0212 00C0      		rjmp .L96
 216:rev2.c        **** 			ADC_status &= ~ADC_NEWREADING;
 969               		.stabn	68,0,216,.LM159-.LFBB4
 970               	.LM159:
 971 0214 8F7B      		andi r24,lo8(-65)
 218:rev2.c        **** 			switch(ADC_status)
 972               		.stabn	68,0,218,.LM160-.LFBB4
 973               	.LM160:
 974 0216 8230      		cpi r24,lo8(2)
 975 0218 01F0      		breq .L64
 976 021a 00F4      		brsh .L67
 977 021c 8130      		cpi r24,lo8(1)
 978 021e 01F0      		breq .+2
 979 0220 00C0      		rjmp .L62
 980 0222 00C0      		rjmp .L63
 981               	.L67:
 982 0224 8430      		cpi r24,lo8(4)
 983 0226 01F4      		brne .+2
 984 0228 00C0      		rjmp .L65
 985 022a 8830      		cpi r24,lo8(8)
 986 022c 01F0      		breq .+2
 987 022e 00C0      		rjmp .L62
 988 0230 00C0      		rjmp .L66
 989               	.L63:
 221:rev2.c        **** 				voltageRead = ADC_reading*voltageReadMulti;
 990               		.stabn	68,0,221,.LM161-.LFBB4
 991               	.LM161:
 992 0232 6091 0000 		lds r22,ADC_reading
 993 0236 7091 0000 		lds r23,ADC_reading+1
 222:rev2.c        **** 				ADC_status = ADC_CURRENT;
 994               		.stabn	68,0,222,.LM162-.LFBB4
 995               	.LM162:
 996 023a 7092 0000 		sts ADC_status,r7
 223:rev2.c        **** 				ADMUX &= 0xF0;
GAS LISTING /tmp/cccvrElj.s 			page 30


 997               		.stabn	68,0,223,.LM163-.LFBB4
 998               	.LM163:
 999 023e 87B1      		in r24,0x7
 1000 0240 807F      		andi r24,lo8(-16)
 1001 0242 87B9      		out 0x7,r24
 224:rev2.c        **** 				ADMUX |= CURRENT_MON;
 1002               		.stabn	68,0,224,.LM164-.LFBB4
 1003               	.LM164:
 1004 0244 389A      		sbi 0x7,0
 225:rev2.c        **** 				if (voltageSetDelay == 0)
 1005               		.stabn	68,0,225,.LM165-.LFBB4
 1006               	.LM165:
 1007 0246 E114      		cp r14,__zero_reg__
 1008 0248 F104      		cpc r15,__zero_reg__
 1009 024a 01F0      		breq .+2
 1010 024c 00C0      		rjmp .L69
 221:rev2.c        **** 				voltageRead = ADC_reading*voltageReadMulti;
 1011               		.stabn	68,0,221,.LM166-.LFBB4
 1012               	.LM166:
 1013 024e 80E0      		ldi r24,0
 1014 0250 90E0      		ldi r25,0
 1015 0252 00D0      		rcall __floatunsisf
 1016 0254 2FE8      		ldi r18,lo8(-113)
 1017 0256 32EB      		ldi r19,lo8(-78)
 1018 0258 41E3      		ldi r20,lo8(49)
 1019 025a 50E4      		ldi r21,lo8(64)
 1020 025c 00D0      		rcall __mulsf3
 1021 025e 00D0      		rcall __fixunssfsi
 1022 0260 4B01      		movw r8,r22
 1023 0262 5C01      		movw r10,r24
 227:rev2.c        **** 					LCD_Cursor(0,3);
 1024               		.stabn	68,0,227,.LM167-.LFBB4
 1025               	.LM167:
 1026 0264 63E0      		ldi r22,lo8(3)
 1027 0266 80E0      		ldi r24,0
 1028 0268 00D0      		rcall LCD_Cursor
 228:rev2.c        **** 					LCD_WriteFloat(voltageRead);
 1029               		.stabn	68,0,228,.LM168-.LFBB4
 1030               	.LM168:
 1031 026a C401      		movw r24,r8
 1032 026c 00D0      		rcall LCD_WriteFloat
 229:rev2.c        **** 					USART_Transmit(voltageRead);
 1033               		.stabn	68,0,229,.LM169-.LFBB4
 1034               	.LM169:
 1035 026e C401      		movw r24,r8
 1036 0270 00D0      		rcall USART_Transmit
 1037 0272 00C0      		rjmp .L69
 1038               	.L64:
 233:rev2.c        **** 				currentRead = ADC_reading*currentReadMulti;
 1039               		.stabn	68,0,233,.LM170-.LFBB4
 1040               	.LM170:
 1041 0274 A090 0000 		lds r10,ADC_reading
 1042 0278 B090 0000 		lds r11,ADC_reading+1
 234:rev2.c        **** 				ADC_status = ADC_PREREGULATOR;
 1043               		.stabn	68,0,234,.LM171-.LFBB4
 1044               	.LM171:
 1045 027c 6092 0000 		sts ADC_status,r6
GAS LISTING /tmp/cccvrElj.s 			page 31


 235:rev2.c        **** 				ADMUX &= 0xF0;
 1046               		.stabn	68,0,235,.LM172-.LFBB4
 1047               	.LM172:
 1048 0280 87B1      		in r24,0x7
 1049 0282 807F      		andi r24,lo8(-16)
 1050 0284 87B9      		out 0x7,r24
 236:rev2.c        **** 				ADMUX |= PREREG;
 1051               		.stabn	68,0,236,.LM173-.LFBB4
 1052               	.LM173:
 1053 0286 399A      		sbi 0x7,1
 237:rev2.c        **** 				if (currentSetDelay == 0)
 1054               		.stabn	68,0,237,.LM174-.LFBB4
 1055               	.LM174:
 1056 0288 C114      		cp r12,__zero_reg__
 1057 028a D104      		cpc r13,__zero_reg__
 1058 028c 01F4      		brne .L69
 239:rev2.c        **** 					LCD_Cursor(1,3);
 1059               		.stabn	68,0,239,.LM175-.LFBB4
 1060               	.LM175:
 1061 028e 63E0      		ldi r22,lo8(3)
 1062 0290 81E0      		ldi r24,lo8(1)
 1063 0292 00D0      		rcall LCD_Cursor
 233:rev2.c        **** 				currentRead = ADC_reading*currentReadMulti;
 1064               		.stabn	68,0,233,.LM176-.LFBB4
 1065               	.LM176:
 1066 0294 B501      		movw r22,r10
 1067 0296 80E0      		ldi r24,0
 1068 0298 90E0      		ldi r25,0
 1069 029a 00D0      		rcall __floatunsisf
 1070 029c 24E1      		ldi r18,lo8(20)
 1071 029e 39E6      		ldi r19,lo8(105)
 1072 02a0 49E0      		ldi r20,lo8(9)
 1073 02a2 5EE3      		ldi r21,lo8(62)
 1074 02a4 00D0      		rcall __mulsf3
 1075 02a6 00D0      		rcall __fixunssfsi
 240:rev2.c        **** 					LCD_WriteFloat(currentRead);
 1076               		.stabn	68,0,240,.LM177-.LFBB4
 1077               	.LM177:
 1078 02a8 CB01      		movw r24,r22
 1079 02aa 00D0      		rcall LCD_WriteFloat
 1080 02ac 00C0      		rjmp .L69
 1081               	.L65:
 245:rev2.c        **** 				ADC_status = ADC_VIN;
 1082               		.stabn	68,0,245,.LM178-.LFBB4
 1083               	.LM178:
 1084 02ae 5092 0000 		sts ADC_status,r5
 246:rev2.c        **** 				ADMUX &= 0xF0;
 1085               		.stabn	68,0,246,.LM179-.LFBB4
 1086               	.LM179:
 1087 02b2 87B1      		in r24,0x7
 1088 02b4 807F      		andi r24,lo8(-16)
 1089 02b6 87B9      		out 0x7,r24
 247:rev2.c        **** 				ADMUX |= VIN_MON;
 1090               		.stabn	68,0,247,.LM180-.LFBB4
 1091               	.LM180:
 1092 02b8 87B1      		in r24,0x7
 1093 02ba 8660      		ori r24,lo8(6)
GAS LISTING /tmp/cccvrElj.s 			page 32


 1094 02bc 00C0      		rjmp .L100
 1095               	.L66:
 251:rev2.c        **** 				ADC_status = ADC_VOLTAGE;
 1096               		.stabn	68,0,251,.LM181-.LFBB4
 1097               	.LM181:
 1098 02be 81E0      		ldi r24,lo8(1)
 1099 02c0 8093 0000 		sts ADC_status,r24
 252:rev2.c        **** 				ADMUX &= 0xF0;
 1100               		.stabn	68,0,252,.LM182-.LFBB4
 1101               	.LM182:
 1102 02c4 87B1      		in r24,0x7
 1103 02c6 807F      		andi r24,lo8(-16)
 1104 02c8 87B9      		out 0x7,r24
 253:rev2.c        **** 				ADMUX |= VOLTAGE_MON;
 1105               		.stabn	68,0,253,.LM183-.LFBB4
 1106               	.LM183:
 1107 02ca 87B1      		in r24,0x7
 1108 02cc 87B9      		out 0x7,r24
 1109               	.L62:
 255:rev2.c        **** 				ADC_status = ADC_VOLTAGE;
 1110               		.stabn	68,0,255,.LM184-.LFBB4
 1111               	.LM184:
 1112 02ce 81E0      		ldi r24,lo8(1)
 1113 02d0 8093 0000 		sts ADC_status,r24
 256:rev2.c        **** 				ADMUX &= 0xF0;
 1114               		.stabn	68,0,256,.LM185-.LFBB4
 1115               	.LM185:
 1116 02d4 87B1      		in r24,0x7
 1117 02d6 807F      		andi r24,lo8(-16)
 1118 02d8 87B9      		out 0x7,r24
 257:rev2.c        **** 				ADMUX |= VOLTAGE_MON;
 1119               		.stabn	68,0,257,.LM186-.LFBB4
 1120               	.LM186:
 1121 02da 87B1      		in r24,0x7
 1122               	.L100:
 1123 02dc 87B9      		out 0x7,r24
 1124               	.L69:
 260:rev2.c        **** 			ADC_STARTCONVERSION;
 1125               		.stabn	68,0,260,.LM187-.LFBB4
 1126               	.LM187:
 1127 02de 369A      		sbi 0x6,6
 1128 02e0 00C0      		rjmp .L96
 1129               	.LBE9:
 1130               		.size	main, .-main
 1131               		.stabs	"voltageSetDelay:r(6,4)",64,0,74,14
 1132               		.stabs	"currentSetDelay:r(6,4)",64,0,75,12
 1133               		.stabn	192,0,0,.LFBB4-.LFBB4
 1134               		.stabs	"dir:r(0,11)",64,0,167,24
 1135               		.stabn	192,0,0,.LBB9-.LFBB4
 1136               		.stabn	224,0,0,.LBE9-.LFBB4
 1137               		.stabn	224,0,0,.Lscope4-.LFBB4
 1138               	.Lscope4:
 1139               		.stabs	"",36,0,0,.Lscope4-.LFBB4
 1140               		.stabd	78,0,0
 1141               	.global	backlight
 1142               		.data
 1143               		.type	backlight, @object
GAS LISTING /tmp/cccvrElj.s 			page 33


 1144               		.size	backlight, 1
 1145               	backlight:
 1146 0000 0A        		.byte	10
 1147               		.comm	SW_encoderState,1,1
 1148               		.stabs	"SW_encoderState:G(0,11)",32,0,47,0
 1149               		.stabs	"backlight:G(6,2)",32,0,11,0
 1150               		.text
 1151               		.stabs	"",100,0,0,.Letext0
 1152               	.Letext0:
 1153               		.ident	"GCC: (GNU) 4.7.2"
 1154               	.global __do_copy_data
 1155               	.global __do_clear_bss
GAS LISTING /tmp/cccvrElj.s 			page 34


DEFINED SYMBOLS
                            *ABS*:0000000000000000 rev2.c
     /tmp/cccvrElj.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cccvrElj.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cccvrElj.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cccvrElj.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cccvrElj.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cccvrElj.s:89     .text:0000000000000000 transferToDAC
     /tmp/cccvrElj.s:159    .text:000000000000002a MENU_Home
     /tmp/cccvrElj.s:263    .text:0000000000000080 MENU_Backlight
     /tmp/cccvrElj.s:1145   .data:0000000000000000 backlight
     /tmp/cccvrElj.s:476    .text.startup:0000000000000000 main
                            *COM*:0000000000000001 SW_encoderState

UNDEFINED SYMBOLS
LCD_Clear
LCD_Cursor
LCD_Write
encoderControls
SW_CheckEncoder
SW_Check1
SW_Check2
SW_Check3
SW_Check4
__floatunsisf
__divsf3
__fixunssfsi
__mulsf3
SW_Initialize
LCD_Initialize
ADC_initialize
USART_Initialize
LCD_WriteFloat
ADC_status
ADC_reading
USART_Transmit
__do_copy_data
__do_clear_bss
